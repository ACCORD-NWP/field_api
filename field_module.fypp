! Rank and shape definitions for simple templating
!
! Note that the ranks encode coneptual dimensions here, eg. FIELD_2D encodes
! a surface field and FIELD_3D represents a field with a vertical component.
#:include "field_definition.fypp"

MODULE FIELD_MODULE
  ! The FIELD types provided by this module provide data abstractions that
  ! decouple data storage in memory from the data views used in thread-parallel
  ! sections of the code. They are intended to thinly wrap ATLAS_FIELD
  ! objects and provide additional features that may later be
  ! incorporated into Atlas. They can also provide backward-compatibility
  ! for non-Atlas execution modes.

USE PARKIND1, ONLY: JPIM, JPRB
USE OML_MOD, ONLY: OML_MAX_THREADS, OML_MY_THREAD
USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN

IMPLICIT NONE

INTEGER (KIND=JPIM), PARAMETER :: NDEVFRESH = B'00000001', NHSTFRESH = B'00000010'
INTEGER (KIND=JPIM), PARAMETER, PRIVATE :: NH2D = 1, ND2H = 2, NRD = B'00000001', NWR = B'00000010'

#:for dtype, suffix, rank, default in field_descriptors
#:set field_type_name = 'FIELD_%s%sD' % (suffix, rank)
TYPE, ABSTRACT :: ${field_type_name}$
  ! A FIELD encapsulates a single multi-dimensional array and can
  ! provide block-indexed "views" of the data for automating the
  ! allocation and parallel iterration of NPROMA blocks.

  ! TODO: Atlas-based field data storage field
  ! TODO: Do we still need to use pointers here?
  ! TYPE(ATLAS_FIELD), POINTER :: DATA

  ! Storage pointer for non-Atlas backward-compatibility mode
  !
  ! The underlying storage pointer has the rank as the dimension,
  ! where the innermost dimension represents the horizontal and
  ! the outermost one is the block index.
  ${dtype}$, POINTER :: PTR(${shapes[rank]}$) => NULL()

  ! A separate data pointer that can be used to create
  ! a contiguous chunk of host memory to cleanly map to
  ! device, should the %DATA pointer be discontiguous.
  ${dtype}$, POINTER, CONTIGUOUS :: DEVPTR(${shapes[rank]}$) => NULL()

  ! Number of blocks used in the data layout
  INTEGER :: NBLOCKS

  ! Flag indicating whether this field stores real data
  LOGICAL :: ACTIVE = .FALSE.
  ! Flag indicating the use a single block-buffer per thread
  LOGICAL :: THREAD_BUFFER = .FALSE.

  INTEGER(KIND=JPIM) :: LBOUNDS (${rank}$) = [${", ".join (["1"] * rank)}$]
  INTEGER(KIND=JPIM) :: ISTATUS = 0

CONTAINS

  PROCEDURE :: FINAL => ${field_type_name}$_FINAL
  PROCEDURE :: GET_VIEW => ${field_type_name}$_GET_VIEW
  PROCEDURE :: MOVE_DATA_TO_DEVICE_RDONLY => ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDONLY
  PROCEDURE :: MOVE_DATA_TO_DEVICE_RDWR => ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDWR
  PROCEDURE :: MOVE_DATA_FROM_DEVICE_RDONLY => ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDONLY
  PROCEDURE :: MOVE_DATA_FROM_DEVICE_RDWR => ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDWR
  PROCEDURE, PRIVATE :: MOVE_DATA_TO_DEVICE => ${field_type_name}$_MOVE_DATA_TO_DEVICE
  PROCEDURE, PRIVATE :: MOVE_DATA_FROM_DEVICE => ${field_type_name}$_MOVE_DATA_FROM_DEVICE
  PROCEDURE, PRIVATE :: COPY =>  ${field_type_name}$_COPY
END TYPE ${field_type_name}$

#:for dm in data_management_type
TYPE, EXTENDS(${field_type_name}$) :: ${field_type_name}$_${dm}$
CONTAINS
#:if dm == 'WRAPPER'
  PROCEDURE :: INIT => ${field_type_name}$_WRAP, ${field_type_name}$_WRAP_PACKED
#:else
  PROCEDURE :: INIT => ALLOCATE_${field_type_name}$
#:endif
  PROCEDURE :: FINAL => ${field_type_name}$_${dm}$_FINAL
  PROCEDURE :: DELETE_DEVICE => ${field_type_name}$_${dm}$_DELETE_DEVICE
END TYPE ${field_type_name}$_${dm}$

#:endfor

#:endfor

INTERFACE FIELD_DELETE_DEVICE
#:for dtype, suffix, rank, default in field_descriptors
#:set field_type_name = 'FIELD_%s%sD' % (suffix, rank)
  MODULE PROCEDURE :: ${field_type_name}$_WRAPPER_DELETE_DEVICE
  MODULE PROCEDURE :: ${field_type_name}$_OWNER_DELETE_DEVICE
#:endfor
END INTERFACE FIELD_DELETE_DEVICE

INTERFACE CREATE_TEMPORARY_LU
#:for d in [2, 3, 4, 5]
  MODULE PROCEDURE CREATE_TEMPORARY_${d}$D_LU
#:endfor
#:for d in [2, 3]
  MODULE PROCEDURE CREATE_TEMPORARY_INT${d}$D_LU
#:endfor
#:for d in [2]
  MODULE PROCEDURE CREATE_TEMPORARY_LOG${d}$D_LU
#:endfor
END INTERFACE CREATE_TEMPORARY_LU

CONTAINS
!
! CLASS METHODS
!
#:for dtype, suffix, rank, default in field_descriptors
#:set field_type_name = 'FIELD_%s%sD' % (suffix, rank)
  SUBROUTINE ${field_type_name}$_WRAP(SELF, DATA, PERSISTENT, LBOUNDS)
    ! Create FIELD object by wrapping existing data
    CLASS(${field_type_name}$_WRAPPER), INTENT(INOUT) :: SELF
    ${dtype}$, TARGET, INTENT(IN) :: DATA(${shapes[rank]}$)
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${rank}$)
    LOGICAL :: LLPERSISTENT

    LLPERSISTENT = .TRUE.
    IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
    IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS

    SELF%PTR => DATA
    SELF%ACTIVE = .TRUE.
    SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
    SELF%NBLOCKS = SIZE(SELF%PTR, ${rank}$)

    SELF%ISTATUS = NHSTFRESH

    IF (.NOT. LLPERSISTENT) THEN
      IF (OML_MAX_THREADS() /= SIZE (DATA, ${rank}$)) THEN
        CALL ABOR1 ('${field_type_name}$_WRAP: DIMENSION MISMATCH')
      ENDIF
    ENDIF

  END SUBROUTINE ${field_type_name}$_WRAP

  SUBROUTINE ${field_type_name}$_WRAP_PACKED(SELF, DATA, IDX, LBOUNDS)
    ! Create FIELD object packed in a multi-field buffer by storing a
    ! contiguous pointer to existing data and an index.
    CLASS(${field_type_name}$_WRAPPER), INTENT(INOUT) :: SELF
    ${dtype}$, TARGET, INTENT(IN) :: DATA(${shapes[rank+1]}$)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${rank}$)

    IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS

    SELF%PTR => DATA(${shapes[rank-1]}$,IDX,:)
    SELF%ACTIVE = .TRUE.
    SELF%THREAD_BUFFER = .FALSE.
    SELF%NBLOCKS = SIZE(SELF%PTR, ${rank}$)
  END SUBROUTINE ${field_type_name}$_WRAP_PACKED

  SUBROUTINE ALLOCATE_${field_type_name}$ (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
    ! Create FIELD object by explicitly allocating new data
    !
    ! Please note that SHAPE is the conceptual shape without the block dimension
    CLASS(${field_type_name}$_OWNER), TARGET :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(${rank-1}$)
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
    LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(${rank}$)
    INTEGER(KIND=JPIM) :: NBLK

    IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS

    ! By default we allocate thread-local temporaries
    SELF%THREAD_BUFFER = .TRUE.
    NBLK = OML_MAX_THREADS()

    IF (PRESENT(PERSISTENT)) THEN
      IF (PERSISTENT) THEN
        ! Adjust outer dim for full-sized persistent blocked arrays
        IF (.NOT. PRESENT(NBLOCKS)) CALL &
         & ABOR1('${field_type_name}$_ALLOCATE : NBLOCKS not given for persistent allocation!')
        SELF%THREAD_BUFFER = .FALSE.
        NBLK = NBLOCKS
      END IF
    END IF

    ! Allocate storage array and store metadata
    ALLOCATE(SELF%PTR(${','.join('SHAPE(%d)'%(r+1) for r in range(rank-1))}$,NBLK))
    SELF%ACTIVE = .TRUE.
    SELF%NBLOCKS = SIZE(SELF%PTR, ${rank}$)
  END SUBROUTINE ALLOCATE_${field_type_name}$

  FUNCTION ${field_type_name}$_GET_VIEW(SELF, BLOCK_INDEX, ZERO) RESULT(VIEW_PTR)
    ! Updates internal view and exports it to an external pointer
    CLASS(${field_type_name}$), TARGET :: SELF
    ${dtype}$, POINTER :: VIEW_PTR(${shapes[rank-1]}$)
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
    INTEGER(KIND=JPIM) :: IDX

    IDX = BLOCK_INDEX
    IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
    IF (SELF%ACTIVE) THEN
      VIEW_PTR (${lbptr (rank-1)}$) => SELF%PTR(${','.join(':' for _ in range(rank-1))}$,IDX)
    ELSE
      VIEW_PTR (${lbptr (rank-1)}$) => NULL()
    END IF

    IF (PRESENT(ZERO)) THEN
      IF (ZERO) VIEW_PTR(${shapes[rank-1]}$) = ${default}$
    END IF
  END FUNCTION ${field_type_name}$_GET_VIEW

  SUBROUTINE ${field_type_name}$_WRAPPER_DELETE_DEVICE(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(${field_type_name}$_WRAPPER), TARGET :: SELF

!$acc exit data delete(SELF%DEVPTR)
    DEALLOCATE(SELF%DEVPTR)
  END SUBROUTINE ${field_type_name}$_WRAPPER_DELETE_DEVICE

  SUBROUTINE ${field_type_name}$_OWNER_DELETE_DEVICE(SELF)
    ! Delete the copy of this field on GPU device
    CLASS(${field_type_name}$_OWNER), TARGET :: SELF

!$acc exit data delete(SELF%DEVPTR)
    NULLIFY(SELF%DEVPTR)
  END SUBROUTINE ${field_type_name}$_OWNER_DELETE_DEVICE

  SUBROUTINE ${field_type_name}$_FINAL(SELF)
    ! Finalizes field and dealloactes owned data
    CLASS(${field_type_name}$) :: SELF
    NULLIFY(SELF%PTR)
    IF (ASSOCIATED (SELF%DEVPTR)) THEN
      !$acc exit data delete (SELF%DEVPTR)
      DEALLOCATE (SELF%DEVPTR)
      NULLIFY (SELF%DEVPTR)
    ENDIF
  END SUBROUTINE ${field_type_name}$_FINAL

  SUBROUTINE ${field_type_name}$_WRAPPER_FINAL(SELF)
    ! Finalizes field and dealloactes owned data
    CLASS(${field_type_name}$_WRAPPER) :: SELF
    CALL SELF%${field_type_name}$%FINAL
  END SUBROUTINE ${field_type_name}$_WRAPPER_FINAL

  SUBROUTINE ${field_type_name}$_OWNER_FINAL(SELF)
    ! Finalizes field and dealloactes owned data
    CLASS(${field_type_name}$_OWNER) :: SELF
    IF (ASSOCIATED(SELF%PTR)) THEN
      DEALLOCATE(SELF%PTR)
    END IF
    CALL SELF%${field_type_name}$%FINAL
  END SUBROUTINE ${field_type_name}$_OWNER_FINAL

  SUBROUTINE ${field_type_name}$_COPY (SELF, KDIR)
  CLASS(${field_type_name}$) :: SELF
  INTEGER (KIND=JPIM), INTENT (IN) :: KDIR
  INTEGER (KIND=JPIM) :: JDIM

  JDIM = ${field_type_name}$_GET_LAST_CONTIGUOUS_DIMENSION (SELF%PTR)

  SELECT CASE (JDIM)
#:for d in range (rank + 1)
    CASE (${d}$)
      CALL COPY_DIM${d}$_CONTIGUOUS (SELF%PTR, SELF%DEVPTR, KDIR)
#:endfor
  END SELECT

  CONTAINS

#:for d in range (0, rank+1)
    SUBROUTINE COPY_DIM${d}$_CONTIGUOUS (HST, DEV, KDIR)
    USE OPENACC
    ${dtype}$, POINTER :: HST (${shapes[rank]}$), DEV (${shapes[rank]}$)
    INTEGER (KIND=JPIM), INTENT (IN) :: KDIR
    INTEGER (KIND=JPIM) :: ISIZE
    INTEGER :: ${', '.join (['J'] + list (map (lambda i: 'J' + str (i+1), range (d, rank))))}$

  #:for e in range (rank, d, -1)
    ${'  ' * (rank - e)}$DO J${e}$ = LBOUND (HST, ${e}$), UBOUND (HST, ${e}$)
  #:endfor
  #:set ar = ', '.join ([':'] * d  + list (map (lambda i: 'J' + str (i+1), range (d, rank))))
  #:set indent = '  ' * (rank - e)
    #:if d == 0
    ${indent}$  ISIZE = KIND (HST)
    #:else
    ${indent}$  ISIZE = KIND (HST) * SIZE (HST (${ar}$))
    #:endif
    ${indent}$  IF (KDIR == NH2D) THEN
    ${indent}$    !$acc host_data use_device (DEV)
    ${indent}$    CALL ACC_MEMCPY_TO_DEVICE (DEV (${ar}$), HST (${ar}$), ISIZE)
    ${indent}$    !$acc end host_data
    ${indent}$  ELSEIF (KDIR == ND2H) THEN
    ${indent}$    !$acc host_data use_device (DEV)
    ${indent}$    CALL ACC_MEMCPY_FROM_DEVICE (HST (${ar}$), DEV (${ar}$), ISIZE)
    ${indent}$    !$acc end host_data
    ${indent}$  ENDIF
  #:for e in range (d, rank)
    ${'  ' * (rank - e - 1)}$ENDDO
  #:endfor
    END SUBROUTINE

#:endfor
  END SUBROUTINE ${field_type_name}$_COPY


  SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE (SELF, MODE, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    INTEGER (KIND=JPIM),                INTENT (IN) :: MODE
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    IF (IAND (SELF%ISTATUS, NHSTFRESH) == 0) THEN
      CALL SELF%COPY (ND2H)
      SELF%ISTATUS = IOR (SELF%ISTATUS, NHSTFRESH)
    ENDIF
    PTR (${lbptr (rank)}$) => SELF%PTR (${','.join(':' for _ in range(rank))}$)
    IF (IAND (MODE, NWR) /= 0) THEN
      SELF%ISTATUS = IAND (SELF%ISTATUS, NOT (NDEVFRESH))
    ENDIF

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE

  SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDONLY (SELF, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    CALL ${field_type_name}$_MOVE_DATA_FROM_DEVICE (SELF, NRD, PTR)

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDONLY

  SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDWR (SELF, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    CALL ${field_type_name}$_MOVE_DATA_FROM_DEVICE (SELF, IOR (NRD, NWR), PTR)

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_FROM_DEVICE_RDWR

  SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE (SELF, MODE, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    INTEGER (KIND=JPIM),                INTENT (IN) :: MODE
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    IF (IAND (SELF%ISTATUS, NDEVFRESH) == 0) THEN
      IF (.NOT. ASSOCIATED (SELF%DEVPTR)) THEN
        ALLOCATE (SELF%DEVPTR, MOLD=SELF%PTR)
        !$acc enter data create (SELF%DEVPTR)
      ENDIF
      CALL SELF%COPY (NH2D)
      SELF%ISTATUS = IOR (SELF%ISTATUS, NDEVFRESH)
    ENDIF
    PTR (${lbptr (rank)}$) => SELF%DEVPTR (${','.join(':' for _ in range(rank))}$)
    IF (IAND (MODE, NWR) /= 0) THEN
      SELF%ISTATUS = IAND (SELF%ISTATUS, NOT (NHSTFRESH))
    ENDIF

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE

  SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDONLY (SELF, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    CALL ${field_type_name}$_MOVE_DATA_TO_DEVICE (SELF, NRD, PTR)

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDONLY

  SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDWR (SELF, PTR)
    CLASS(${field_type_name}$), INTENT (INOUT) :: SELF
    ${dtype}$, POINTER, INTENT(INOUT) :: PTR(${shapes[rank]}$)

    CALL ${field_type_name}$_MOVE_DATA_TO_DEVICE (SELF, IOR (NRD, NWR), PTR)

  END SUBROUTINE ${field_type_name}$_MOVE_DATA_TO_DEVICE_RDWR

#:endfor

!
! HELPERS
!

#:def create_temporary (dims, type)
#:for d in dims
#:set field_type_name = 'FIELD_%s%sD' % (type, d)
  SUBROUTINE CREATE_TEMPORARY_${type}$${d}$D_LU (FIELD_PTR, UBOUNDS, LBOUNDS, PERSISTENT)

    CLASS(${field_type_name}$_OWNER), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), INTENT(IN) :: UBOUNDS (${d}$)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: LBOUNDS (${d}$)
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: NBLOCKS
    INTEGER(KIND=JPIM) :: ISIZE (${d}$)

    ISIZE = UBOUNDS
    IF (PRESENT (LBOUNDS)) ISIZE = ISIZE - LBOUNDS + 1

    ALLOCATE(FIELD_PTR)
    NBLOCKS = UBOUNDS (${d}$)
    CALL ALLOCATE_${field_type_name}$ (FIELD_PTR, SHAPE=ISIZE(1:${d}$-1), NBLOCKS=NBLOCKS, PERSISTENT=PERSISTENT, LBOUNDS=LBOUNDS)

    FIELD_PTR%ISTATUS = NHSTFRESH

  END SUBROUTINE CREATE_TEMPORARY_${type}$${d}$D_LU

#:endfor
#:enddef

$:create_temporary ([2, 3, 4, 5], '')
$:create_temporary ([2, 3      ], 'INT')
$:create_temporary ([2         ], 'LOG')

#:for dtype, suffix, rank, default in field_descriptors
#:set field_type_name = 'FIELD_%s%sD' % (suffix, rank)
  INTEGER (KIND=JPIM) FUNCTION ${field_type_name}$_GET_LAST_CONTIGUOUS_DIMENSION (PTR) RESULT (JDIM)
  ${dtype}$, POINTER :: PTR (${shapes[rank]}$)
  INTEGER*8 :: ISTRIDE (${rank}$)
  INTEGER (KIND=JPIM) :: J

  ISTRIDE (1) = KIND (PTR)
  DO J = 2, ${rank}$
    ISTRIDE (J) = ISTRIDE (J-1) * SIZE (PTR, J-1) 
  ENDDO

  JDIM = 0
#:for d in range (1, rank+1)
  #:set ind0 = ['1'] * rank
  #:set ind1 = ['1'] * (d - 1) + ['2'] + ['1'] * (rank - d)
  IF (LOC (PTR (${', '.join (ind1)}$)) - LOC (PTR (${', '.join (ind0)}$)) /= ISTRIDE (${d}$)) THEN
    RETURN
  ENDIF

  JDIM = ${d}$

#:endfor
  END FUNCTION ${field_type_name}$_GET_LAST_CONTIGUOUS_DIMENSION
#:endfor

END MODULE FIELD_MODULE
